#include "cryptowrapper/aes256.h"

namespace prototype_functions {

    std::array<uint8_t, EVP_MAX_IV_LENGTH> generate_initialization_vector() {
        std::array<uint8_t, EVP_MAX_IV_LENGTH> iv{};
        if (RAND_bytes(iv.data(), EVP_MAX_IV_LENGTH) != 1) 
            throw std::runtime_error("Error at RAND_bytes");
        return iv;
    }
    std::array<uint8_t, 32> generate_key() {
        std::array<uint8_t, 32> key{};
        
        if (RAND_bytes(key.data(), 32) != 1)
            std::cout << "error at key generation\n";
        return key;
    }
    std::vector<uint8_t> aes_encrypt(
        const std::vector<uint8_t>& plaintext, 
        const std::array<uint8_t, 32>& key, //idk the name for it so its a magic number but 32 is the keylength in bytes
        const std::array<uint8_t, 16>& iv //same as above but 16 is the byte length for a chunk for aes256
    ) {
        std::vector<uint8_t> ciphertext(plaintext.size() + EVP_CIPHER_block_size(EVP_aes_256_cbc()));
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx)
            throw std::runtime_error("EVP_CIPHER_CTX_new has failed");
        
        int32_t len = 0;
        int32_t ciphertext_len = 0;

        if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key.data(), iv.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_EncryptInit_ex has failed");
        }

        if (EVP_EncryptUpdate(ctx, ciphertext.data(), &len, plaintext.data(), plaintext.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_EncryptUpdate has failed");
        }
        ciphertext_len = len;

        if (EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_EncryptFinal has failed");
        }
        ciphertext_len += len;

        ciphertext.resize(ciphertext_len);
        EVP_CIPHER_CTX_free(ctx);
        
        return ciphertext;
    }
    std::vector<uint8_t> aes_decrypt(
        const std::vector<uint8_t>& ciphertext,
        const std::array<uint8_t, 32>& key,
        const std::array<uint8_t, 16>& iv
    ) {
        std::vector<uint8_t> plaintext(ciphertext.size());

        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx) 
            throw std::runtime_error("EVP_CIPHER_CTX_new has failed");
        int32_t len = 0;
        int32_t plaintext_len = 0;

        if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key.data(), iv.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_DecryptInit_ex has failed");
        }

        if (EVP_DecryptUpdate(ctx, plaintext.data(), &len, ciphertext.data(), ciphertext.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_DecryptUpdate has failed");
        }
        plaintext_len = len;
        if (EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_DecryptFinal_ex has failed (wrong key/IV or corrupted ciphertext)");
        }
        plaintext_len += len;
        plaintext.resize(plaintext_len);
        EVP_CIPHER_CTX_free(ctx);

        return plaintext;
    }
    
    //This function is ai generated by OpenAI chatgpt and will be removed
    void openssl_sanity_check()
    {
        std::cout << "OpenSSL version (macro): "
                << OPENSSL_VERSION_TEXT << '\n';

        std::cout << "OpenSSL version (runtime): "
                << OpenSSL_version(OPENSSL_VERSION) << '\n';
    }
}