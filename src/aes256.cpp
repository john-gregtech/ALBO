#include "cryptowrapper/aes256.h"

namespace prototype_functions {
    
    std::array<unsigned char, 16> generate_initialization_vector() {
        std::array<unsigned char, 16> iv{};
        if (RAND_bytes(iv.data(), 16) != 1) 
            std::cout << "error at initialization vector generation\n";
        return iv;
    }
    std::array<unsigned char, 32> generate_key() {
        std::array<unsigned char, 32> key{};
        
        if (RAND_bytes(key.data(), 32) != 1)
            std::cout << "error at key generation\n";
        return key;
    }
    
    std::vector<unsigned char> aes_encrypt(
        const std::vector<unsigned char>& plaintext, 
        const std::array<unsigned char, 32>& key, 
        const std::array<unsigned char, 16>& iv
    ) {
        std::vector<unsigned char> ciphertext(plaintext.size() + EVP_CIPHER_block_size(EVP_aes_256_cbc()));
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx)
            throw std::runtime_error("EVP_CIPHER_CTX_new has failed");
        
        int len = 0;
        int ciphertext_len = 0;

        if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key.data(), iv.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_EncryptInit_ex has failed");
        }

        if (EVP_EncryptUpdate(ctx, ciphertext.data(), &len, plaintext.data(), plaintext.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_EncryptUpdate has failed");
        }
        ciphertext_len = len;

        if (EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_EncryptFinal has failed");
        }
        ciphertext_len += len;

        ciphertext.resize(ciphertext_len);
        EVP_CIPHER_CTX_free(ctx);
        
        return ciphertext;
    }
    std::vector<unsigned char> aes_decrypt(
        const std::vector<unsigned char>& ciphertext,
        const std::array<unsigned char, 32>& key,
        const std::array<unsigned char, 16>& iv
    ) {
        std::vector<unsigned char> plaintext(ciphertext.size());

        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx) 
            throw std::runtime_error("EVP_CIPHER_CTX_new has failed");
        int len = 0;
        int plaintext_len = 0;

        if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key.data(), iv.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_DecryptInit_ex has failed");
        }

        if (EVP_DecryptUpdate(ctx, plaintext.data(), &len, ciphertext.data(), ciphertext.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_DecryptUpdate has failed");
        }
        plaintext_len = len;
        if (EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("EVP_DecryptFinal_ex has failed (wrong key/IV or corrupted ciphertext)");
        }
        plaintext_len += len;
        plaintext.resize(plaintext_len);
        EVP_CIPHER_CTX_free(ctx);

        return plaintext;
    }
    
    //This function is ai generated by OpenAI chatgpt and will be removed
    void openssl_sanity_check()
    {
        std::cout << "OpenSSL version (macro): "
                << OPENSSL_VERSION_TEXT << '\n';

        std::cout << "OpenSSL version (runtime): "
                << OpenSSL_version(OPENSSL_VERSION) << '\n';
    }
}